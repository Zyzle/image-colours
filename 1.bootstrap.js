(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _zyzle_image_kmeans__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zyzle/image-kmeans */ \"./node_modules/@zyzle/image-kmeans/image_kmeans.js\");\n\n\nconst dropZone = document.getElementById('drop-zone');\nconst plot = document.getElementById(\"plot\");\n\nconst layout = {\n\tautosize: true,\n\tscene: {\n\t\taspectratio: {\n\t\t\tx: 1,\n\t\t\ty: 1,\n\t\t\tz: 1,\n\t\t},\n\t\txaxis: {\n\t\t\ttype: \"linear\",\n\t\t\tzeroline: false,\n\t\t\ttitle: \"Red\",\n\t\t},\n\t\tyaxis: {\n\t\t\ttype: \"linear\",\n\t\t\tzeroline: false,\n\t\t\ttitle: \"Green\",\n\t\t},\n\t\tzaxis: {\n\t\t\ttype: \"linear\",\n\t\t\tzeroline: false,\n\t\t\ttitle: \"Blue\",\n\t\t},\n\t},\n\ttitle: \"Image colour clustering\",\n};\n\nconst config = { responsive: true };\n\nfunction unpack(rows, key) {\n\treturn rows.map((r) => r[key]);\n}\n\ndropZone.addEventListener('drop', async (e) => {\n\te.preventDefault();\n\n\tif (e.dataTransfer.items) {\n\t\tif (e.dataTransfer.items[0].kind === \"file\") {\n\t\t\tconst file = e.dataTransfer.items[0].getAsFile();\n\t\t\tconst output = document.getElementById(\"image-display\");\n\t\t\toutput.src = URL.createObjectURL(file);\n\n\t\t\tcreateImageBitmap(file).then((ibm) => {\n\t\t\t\tlet ctx;\n\n\t\t\t\tconsole.time('finding canvas element');\n\t\t\t\tif (typeof OffscreenCanvasRenderingContext === \"function\") {\n\t\t\t\t\tconst canvas = new OffscreenCanvas(ibm.width, ibm.height);\n\t\t\t\t\tctx = canvas.getContext(\"2d\");\n\t\t\t\t} else {\n\t\t\t\t\tconst canvas = document.createElement(\"canvas\");\n\t\t\t\t\tctx = canvas.getContext(\"2d\");\n\t\t\t\t\tctx.canvas.height = ibm.height;\n\t\t\t\t\tctx.canvas.width = ibm.width;\n\t\t\t\t}\n\t\t\t\tconsole.timeEnd(\"finding canvas element\");\n\n\t\t\t\tconsole.time('drawing image');\n\t\t\t\tctx.drawImage(ibm, 0, 0);\n\t\t\t\tconsole.timeEnd(\"drawing image\");\n\n\t\t\t\tconst wasmStart = Date.now();\n\t\t\t\tconst wasmResult = _zyzle_image_kmeans__WEBPACK_IMPORTED_MODULE_0__[\"find_colors\"](ctx, ibm.width, ibm.height);\n\t\t\t\tconst wasmEnd = Date.now();\n\n\t\t\t\tconst wasmSwatches = document.getElementById(\"wasm-swatches\");\n\t\t\t\tconst wasmTime = document.getElementById(\"wasm-time\");\n\t\t\t\twasmTime.textContent = `${wasmEnd - wasmStart}ms`;\n\n\t\t\t\twasmSwatches.textContent = \"\";\n\n\t\t\t\tfor (let i = 0; i < wasmResult.length; i++) {\n\t\t\t\t\tlet swatch = document.createElement(\"span\");\n\n\t\t\t\t\tconst color = document.createTextNode(wasmResult[i]);\n\t\t\t\t\tswatch.appendChild(color);\n\t\t\t\t\tswatch.classList.add(\"p-2\");\n\t\t\t\t\tswatch.classList.add(\"mb-2\");\n\t\t\t\t\tswatch.style.backgroundColor = wasmResult[i];\n\n\t\t\t\t\twasmSwatches.appendChild(swatch);\n\t\t\t\t}\n\n\t\t\t\tconst jsStart = Date.now();\n\t\t\t\tconst jsResult = jsFindColors(ctx, ibm.width, ibm.height);\n\t\t\t\tconst jsEnd = Date.now();\n\n\t\t\t\tconst jsSwatches = document.getElementById(\"js-swatches\");\n        const jsTime = document.getElementById(\"js-time\");\n        jsTime.textContent = `${jsEnd - jsStart}ms`;\n        jsSwatches.textContent = \"\";\n\n        for (let i = 0; i < jsResult.length; i++) {\n          let swatch = document.createElement(\"span\");\n\n          const color = document.createTextNode(jsResult[i]);\n          swatch.appendChild(color);\n          swatch.classList.add(\"p-2\");\n          swatch.classList.add(\"mb-2\");\n          swatch.style.backgroundColor = jsResult[i];\n\n          jsSwatches.appendChild(swatch);\n        }\n\n\t\t\t\t// console.log(`Time taken: ${end - start}ms`);\n\n\t\t\t\t// // PLOT DATA\n\n\t\t\t\t// const plotData = [\n\t\t\t\t// \t{\n\t\t\t\t// \t\tx: unpack(colorData, \"r\"),\n\t\t\t\t// \t\ty: unpack(colorData, \"g\"),\n\t\t\t\t// \t\tz: unpack(colorData, \"b\"),\n\t\t\t\t// \t\tmode: \"markers\",\n\t\t\t\t// \t\ttype: \"scatter3d\",\n\t\t\t\t// \t\tmarker: {\n\t\t\t\t// \t\t\tcolor: colorData.map((c) => `rgb(${c.r}, ${c.g}, ${c.b})`),\n\t\t\t\t// \t\t\tsize: 2,\n\t\t\t\t// \t\t},\n\t\t\t\t// \t},\n\t\t\t\t// ];\n\n\t\t\t\t// Plotly.newPlot(plot, plotData, layout, config);\n\n\t\t\t\t// // END PLOT DATA\n\t\t\t});\n\t\t}\n\t}\n});\n\ndropZone.addEventListener('dragover', e => {\n\te.preventDefault();\n});\n\n\nfunction calcEuclideanDist(p, q) {\n  return Math.sqrt(\n    Math.pow(p.r - q.r, 2) + Math.pow(p.g - q.g, 2) + Math.pow(p.b - q.b, 2)\n  );\n}\n\nfunction calcNewClusters(kClusters, colorData) {\n  const clusteredData = colorData.reduce(\n    (prev, curr) => {\n      const distances = kClusters.map((k) => calcEuclideanDist(k, curr));\n      const minDistance = distances.reduce((a, b) => Math.min(a, b), Infinity);\n      const selectedK = distances.findIndex((e) => e === minDistance);\n      prev[selectedK] = [...prev[selectedK], curr];\n      return prev;\n    },\n    Array.from({ length: 8 }, () => [])\n  );\n\n  const newKs = clusteredData.map((colors) => {\n    let r = 0;\n    let g = 0;\n    let b = 0;\n\n    colors.forEach((color) => {\n      r += color.r;\n      g += color.g;\n      b += color.b;\n    });\n\n    return {\n      r: Math.round(r / colors.length),\n      g: Math.round(g / colors.length),\n      b: Math.round(b / colors.length),\n    };\n  });\n\n  return newKs;\n}\n\nfunction jsFindColors(ctx, imageWidth, imageHeight) {\n\tconsole.time('Build color data');\n\tconst imageData = ctx.getImageData(0, 0, imageWidth, imageHeight).data;\n\n  let colorData = [];\n\n  for (let i = 0; i < imageData.length; i += 4) {\n    const colStr = [imageData[i], imageData[i + 1], imageData[i + 2]].join(\",\");\n\n    colorData.push(colStr);\n  }\n\n  colorData = [...new Set(colorData)];\n\n  colorData = colorData.map((v) => {\n    const rgb = v.split(\",\");\n    return {\n      r: parseInt(rgb[0]),\n      g: parseInt(rgb[1]),\n      b: parseInt(rgb[2]),\n    };\n  });\n\n  console.timeEnd(\"Build color data\");\n\n  let kClusters = Array.from({ length: 8 }, () => {\n    return colorData[Math.floor(Math.random() * colorData.length)];\n  });\n\n  let iterations = 0;\n  let distanceShift = 0;\n  let newClusters = [];\n\n  do {\n    distanceShift = 0;\n    console.time(\"Calc new clusters\");\n    newClusters = calcNewClusters(kClusters, colorData);\n    console.timeEnd(\"Calc new clusters\");\n\n    newClusters.forEach((v, i) => {\n      distanceShift += calcEuclideanDist(v, kClusters[i]);\n    });\n\n    distanceShift = distanceShift / newClusters.length;\n\n    kClusters = newClusters;\n    iterations += 1;\n  } while (distanceShift >= 5 && iterations < 10);\n\n\treturn kClusters.map(\n    (k) => `#${k.r\n\t\t\t\t.toString(16).padStart(2, \"0\")}${k.g\n        .toString(16)\n        .padStart(2, \"0\")}${k.b\n\t\t\t\t.toString(16)\n\t\t\t\t.padStart(2, \"0\")}`\n  );\n}\n\n//# sourceURL=webpack:///./index.js?");

/***/ })

}]);